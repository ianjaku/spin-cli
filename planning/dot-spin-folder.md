# .spin Folder Architecture

## Problem

Currently, spin requires a JavaScript/TypeScript config file that imports from `spin-cli`:

```typescript
import { defineConfig, shell, docker } from 'spin-cli';
```

This creates several friction points:

1. **Non-JS projects** need to create `package.json` and run `npm install` just for config
2. **JS projects** need to add spin-cli as a devDependency, requiring team buy-in
3. **Solo adoption** is blocked - one developer can't try spin without a PR to package.json
4. Without proper setup, the import fails with "module not found"

## Solution

**Always** use a `.spin/` folder system where:

1. `spin init` generates `.spin/cli.ts` containing all helper functions and types
2. The user's `spin.config.ts` imports from `./.spin/cli` (relative import)
3. spin auto-regenerates `.spin/cli.ts` on every run to stay in sync

This approach is used for **all projects** (JS and non-JS alike), providing:

- Full type safety and IDE support
- Zero dependencies on node_modules
- Instant setup (no npm install)
- Personal adoption without team buy-in
- Consistent experience everywhere

---

## Adoption Modes

spin supports two adoption modes with the same underlying mechanism:

### Personal Adoption (Zero Footprint)

One developer tries spin without affecting the team:

```
my-project/
├── .gitignore                   # Add: .spin/ and spin.config.ts
├── spin.config.ts              # Personal config (NOT committed)
├── .spin/
│   └── cli.ts                  # Auto-generated (NOT committed)
├── src/
└── ...
```

**What to add to `.gitignore`:**
```
# Personal spin config (remove these lines for team adoption)
.spin/
spin.config.ts
```

- No PR needed
- No package.json changes
- Team doesn't know spin exists
- Developer can evaluate spin freely

### Team Adoption (Shared Config)

Team decides to standardize on spin:

```
my-project/
├── spin.config.ts              # Shared config (committed)
├── .spin/
│   ├── cli.ts                  # Auto-generated (NOT committed)
│   └── .gitignore              # Ignores cli.ts (committed)
├── src/
└── ...
```

**What gets committed:**

| File | Committed? | Reason |
|------|-----------|--------|
| `spin.config.ts` | Yes | Shared team configuration |
| `.spin/.gitignore` | Yes | Ensures cli.ts is ignored for everyone |
| `.spin/cli.ts` | No | Auto-generated on each `spin` run |

**What to add to root `.gitignore`:**
```
# spin CLI generated files
.spin/cli.ts
```

### Migration: Personal → Team

When ready to share with the team:

1. Remove `spin.config.ts` and `.spin/` from `.gitignore`
2. Create `.spin/.gitignore` with `cli.ts`
3. Commit `spin.config.ts` and `.spin/.gitignore`
4. Team members just run `spin` - it auto-generates `.spin/cli.ts`

---

## User Experience

### First Time Setup (Any Project)

```bash
# Install spin globally (one time)
$ npm install -g spin-cli

# Initialize in any project (Go, Rust, Python, JS, anything)
$ cd my-project
$ spin init

Created .spin/cli.ts
Created spin.config.ts (example)

# For personal use, add to .gitignore:
#   .spin/
#   spin.config.ts

# Edit spin.config.ts with full IDE support (types, autocomplete)
$ spin up
```

### After Cloning (Team Adoption)

```bash
$ git clone <repo-with-spin-config>
$ spin up

# spin detects spin.config.ts exists
# Auto-generates .spin/cli.ts (instant, no npm install)
# Loads config and starts services
```

### Existing Config, New Machine

```bash
$ spin up
# .spin/cli.ts missing? Auto-regenerated.
# Always matches your installed spin version.
```

---

## Implementation Details

### 1. Generated `.spin/cli.ts`

This file contains all exports that users need in their config. It's self-contained with no external dependencies.

```typescript
// .spin/cli.ts
// Auto-generated by spin v0.1.0 - DO NOT EDIT
// Regenerated on each spin run to stay in sync

// ============================================================================
// Types
// ============================================================================

export type RunnableStatus = 'stopped' | 'starting' | 'running' | 'error';

export interface RunnableDefinition {
  type: 'shell' | 'docker';
  name?: string;
  description?: string;
  command?: string;
  cwd?: string;
  env?: Record<string, string>;
  dependsOn?: string[];
  readyWhen?: (output: string) => boolean;
}

export interface SpinConfig {
  runnables: Record<string, RunnableDefinition>;
  groups?: Record<string, string[]>;
  defaults?: {
    autoRestart?: boolean;
    env?: Record<string, string>;
    maxOutputLines?: number;
  };
  shellCommands?: string[];
  scripts?: ScriptSource[];
}

export type ShellOptions = Omit<RunnableDefinition, 'type' | 'command'>;
export type DockerOptions = Omit<RunnableDefinition, 'type' | 'command'> & {
  ports?: string[];
  volumes?: string[];
};

export interface ResolvedScript {
  id: string;
  displayName: string;
  runnerLabel: string;
  command: string;
  cwd: string;
  confirm?: boolean;
  description?: string;
}

export interface ScriptSource {
  type: 'packageScripts' | 'scriptsFolder';
  resolve(): Promise<ResolvedScript[]>;
}

export interface DockerRunnerConfig {
  type: 'docker';
  container: string;
  runner?: string;
}

export interface KubernetesRunnerConfig {
  type: 'kubernetes';
  selector: string;
  container?: string;
  namespace?: string;
  runner?: string;
}

export interface CustomRunnerConfig {
  type: 'custom';
  run: (scriptPath: string) => string;
}

export type RunnerConfig = string | DockerRunnerConfig | KubernetesRunnerConfig | CustomRunnerConfig;

export interface ScriptsFolderOptions {
  label?: string;
  overrides?: Record<string, { confirm?: boolean; description?: string }>;
}

export interface PackageScriptsOptions {
  include?: string[];
  exclude?: string[];
}

// ============================================================================
// Config Helper
// ============================================================================

export function defineConfig(config: SpinConfig): SpinConfig {
  return config;
}

// ============================================================================
// Runnable Helpers
// ============================================================================

export function shell(command: string, options: ShellOptions = {}): RunnableDefinition {
  return {
    type: 'shell',
    command,
    ...options,
  };
}

export function docker(image: string, options: DockerOptions = {}): RunnableDefinition {
  const { ports = [], volumes = [], ...rest } = options;
  
  const args: string[] = ['docker', 'run', '--rm'];
  
  for (const port of ports) {
    args.push('-p', port);
  }
  
  for (const volume of volumes) {
    args.push('-v', volume);
  }
  
  if (rest.env) {
    for (const [key, value] of Object.entries(rest.env)) {
      args.push('-e', `${key}=${value}`);
    }
  }
  
  args.push(image);
  
  return {
    type: 'docker',
    command: args.join(' '),
    ...rest,
  };
}

// ============================================================================
// Script Helpers
// ============================================================================

export const defaultShellCommands = [
  'git', 'bun', 'npm', 'pnpm', 'yarn', 'node', 'docker', 'kubectl', 'make',
];

export function dockerContext(container: string, options?: { runner?: string }): DockerRunnerConfig {
  return {
    type: 'docker',
    container,
    runner: options?.runner,
  };
}

export function kubernetes(options: {
  selector: string;
  container?: string;
  namespace?: string;
  runner?: string;
}): KubernetesRunnerConfig {
  return {
    type: 'kubernetes',
    ...options,
  };
}

// Note: scriptsFolder() and packageScripts() implementations require fs access
// and are handled by the spin runtime, not the config file.
// The config just declares intent; spin resolves at runtime.

export function scriptsFolder(
  path: string,
  runner: RunnerConfig,
  options?: ScriptsFolderOptions
): ScriptSource {
  return {
    type: 'scriptsFolder',
    // @ts-expect-error - resolved by spin runtime
    _path: path,
    _runner: runner,
    _options: options,
    async resolve() { return []; }, // Placeholder - spin runtime handles this
  } as ScriptSource;
}

export function packageScripts(options?: PackageScriptsOptions): ScriptSource {
  return {
    type: 'packageScripts',
    // @ts-expect-error - resolved by spin runtime
    _options: options,
    async resolve() { return []; }, // Placeholder - spin runtime handles this
  } as ScriptSource;
}
```

### 2. Config Loader Changes

Update `src/config/loader.ts` to always ensure `.spin/cli.ts` exists before loading config:

```typescript
// src/config/loader.ts

import { existsSync, writeFileSync, mkdirSync, readFileSync } from 'node:fs';
import { join } from 'node:path';

const CONFIG_NAMES = [
  'spin.config.ts',
  'spin.config.js',
  'spin.config.mjs',
];

const SPIN_FOLDER = '.spin';
const CLI_FILE = 'cli.ts';

/**
 * Ensure .spin/cli.ts exists and is up to date.
 * Called before loading config - ALWAYS generates the file.
 */
export function ensureSpinFolder(cwd: string): void {
  const spinFolder = join(cwd, SPIN_FOLDER);
  const cliFile = join(spinFolder, CLI_FILE);
  
  // Create .spin folder if it doesn't exist
  if (!existsSync(spinFolder)) {
    mkdirSync(spinFolder, { recursive: true });
  }
  
  // Generate cli.ts content
  const cliContent = generateCliFile();
  
  // Only write if content changed (avoid unnecessary disk writes / IDE flicker)
  if (existsSync(cliFile)) {
    const existing = readFileSync(cliFile, 'utf-8');
    if (existing === cliContent) return;
  }
  
  writeFileSync(cliFile, cliContent);
}

/**
 * Generate the contents of .spin/cli.ts
 */
function generateCliFile(): string {
  const version = getSpinVersion();
  return `// Auto-generated by spin v${version} - DO NOT EDIT
// Regenerated on each spin run to stay in sync

${CLI_FILE_TEMPLATE}`;
}

// CLI_FILE_TEMPLATE would be the full content shown above,
// either inlined or loaded from a bundled asset
```

### 3. `spin init` Command

Create a new command for initializing spin in any project:

```typescript
// src/commands/init.ts

import { existsSync, writeFileSync, mkdirSync, appendFileSync, readFileSync } from 'node:fs';
import { join } from 'node:path';

interface InitOptions {
  force?: boolean;
  personal?: boolean;  // Add .spin/ and config to .gitignore for solo use
}

export async function init(cwd: string, options: InitOptions = {}): Promise<void> {
  const spinFolder = join(cwd, '.spin');
  const configFile = join(cwd, 'spin.config.ts');
  const gitignore = join(cwd, '.gitignore');
  
  // Check if already initialized
  if (existsSync(configFile) && !options.force) {
    console.log('spin.config.ts already exists. Use --force to overwrite.');
    return;
  }
  
  // Create .spin folder
  if (!existsSync(spinFolder)) {
    mkdirSync(spinFolder, { recursive: true });
    console.log('Created .spin/');
  }
  
  // Generate .spin/cli.ts
  const cliContent = generateCliFile();
  writeFileSync(join(spinFolder, 'cli.ts'), cliContent);
  console.log('Created .spin/cli.ts');
  
  // Create .spin/.gitignore (for team adoption - ignores only cli.ts)
  if (!options.personal) {
    writeFileSync(join(spinFolder, '.gitignore'), 'cli.ts\n');
    console.log('Created .spin/.gitignore');
  }
  
  // Create example spin.config.ts
  const configContent = generateExampleConfig();
  writeFileSync(configFile, configContent);
  console.log('Created spin.config.ts');
  
  // Update root .gitignore
  if (existsSync(gitignore)) {
    const content = readFileSync(gitignore, 'utf-8');
    
    if (options.personal) {
      // Personal mode: ignore everything spin-related
      const additions: string[] = [];
      if (!content.includes('.spin/')) {
        additions.push('.spin/');
      }
      if (!content.includes('spin.config.ts')) {
        additions.push('spin.config.ts');
      }
      if (additions.length > 0) {
        appendFileSync(gitignore, '\n# spin (personal config)\n' + additions.join('\n') + '\n');
        console.log('Updated .gitignore (personal mode)');
      }
    } else {
      // Team mode: only ignore generated cli.ts
      if (!content.includes('.spin/cli.ts')) {
        appendFileSync(gitignore, '\n# spin CLI generated files\n.spin/cli.ts\n');
        console.log('Updated .gitignore');
      }
    }
  }
  
  if (options.personal) {
    console.log('\nDone! (personal mode - config not committed to git)');
  } else {
    console.log('\nDone! Edit spin.config.ts and commit it for your team.');
  }
  console.log('Run `spin up` to start services.');
}

function generateExampleConfig(): string {
  return `/**
 * Spin configuration
 * Run \`spin up\` to start all services
 */
import { defineConfig, shell, docker } from './.spin/cli';

export default defineConfig({
  runnables: {
    // Example: shell command
    // api: shell('go run ./cmd/server', {
    //   description: 'API server',
    //   readyWhen: (output) => output.includes('listening'),
    // }),
    
    // Example: Docker container
    // postgres: docker('postgres:15', {
    //   description: 'PostgreSQL database',
    //   ports: ['5432:5432'],
    //   env: {
    //     POSTGRES_PASSWORD: 'dev',
    //   },
    // }),
  },
  
  groups: {
    // dev: ['api', 'postgres'],
  },
});
`;
}
```

### 4. Auto-Update System

Add version checking and auto-update capability:

```typescript
// src/update.ts

import { execSync } from 'node:child_process';

interface UpdateInfo {
  currentVersion: string;
  latestVersion: string;
  updateAvailable: boolean;
}

/**
 * Check if a newer version of spin is available.
 */
export async function checkForUpdates(): Promise<UpdateInfo> {
  const currentVersion = getSpinVersion();
  
  try {
    // Check npm registry for latest version
    const result = execSync('npm view spin-cli version', { 
      encoding: 'utf-8',
      timeout: 5000,
      stdio: ['pipe', 'pipe', 'pipe'],
    }).trim();
    
    return {
      currentVersion,
      latestVersion: result,
      updateAvailable: result !== currentVersion,
    };
  } catch {
    // Network error or timeout - skip update check
    return {
      currentVersion,
      latestVersion: currentVersion,
      updateAvailable: false,
    };
  }
}

/**
 * Update spin to the latest version.
 */
export async function update(): Promise<void> {
  const info = await checkForUpdates();
  
  if (!info.updateAvailable) {
    console.log(`spin v${info.currentVersion} is already up to date.`);
    return;
  }
  
  console.log(`Updating spin from v${info.currentVersion} to v${info.latestVersion}...`);
  
  try {
    // Detect how spin was installed
    const npmGlobal = execSync('npm root -g', { encoding: 'utf-8' }).trim();
    
    execSync('npm install -g spin-cli@latest', {
      stdio: 'inherit',
    });
    
    console.log(`\nUpdated to spin v${info.latestVersion}`);
  } catch (error) {
    console.error('Failed to update. Try running manually:');
    console.error('  npm install -g spin-cli@latest');
  }
}

/**
 * Get current spin version from package.json
 */
function getSpinVersion(): string {
  // This would be replaced at build time or read from package.json
  return '0.1.0';
}
```

### 5. Update Detection Flow

Integrate update checking into the main CLI:

```typescript
// In src/cli.tsx, add to startup:

async function main() {
  const cwd = process.cwd();
  
  // Ensure .spin/cli.ts is up to date (if using .spin folder)
  ensureSpinFolder(cwd);
  
  // Background update check (non-blocking)
  checkForUpdates().then(info => {
    if (info.updateAvailable) {
      // Store notification to show after command completes
      // Or show subtle indicator in UI
    }
  });
  
  // Load config and continue...
}
```

---

## Edge Cases

### 1. Version Mismatch Warning

When regenerating `.spin/cli.ts`, check if config might need updates:

```typescript
function checkCompatibility(cwd: string): void {
  const cliFile = join(cwd, '.spin', 'cli.ts');
  
  if (existsSync(cliFile)) {
    const content = readFileSync(cliFile, 'utf-8');
    const match = content.match(/Auto-generated by spin v([\d.]+)/);
    
    if (match) {
      const generatedVersion = match[1];
      const currentVersion = getSpinVersion();
      
      // Check for major version mismatch
      const [genMajor] = generatedVersion.split('.');
      const [curMajor] = currentVersion.split('.');
      
      if (genMajor !== curMajor) {
        console.warn(
          `Warning: This config was created with spin v${generatedVersion}. ` +
          `You're running v${currentVersion}. Run 'spin init --force' if you have issues.`
        );
      }
    }
  }
}
```

---

## Commands Summary

| Command | Description |
|---------|-------------|
| `spin init` | Initialize spin config and `.spin/` folder |
| `spin init --force` | Regenerate example config (overwrites existing) |
| `spin init --personal` | Also adds `.spin/` and config to `.gitignore` |
| `spin update` | Update spin to latest version |
| `spin doctor` | Check for issues (version mismatch, missing files, etc.) |

---

## Migration Path

### For Existing Users (importing from 'spin-cli')

If you have an existing config importing from `'spin-cli'`:

```bash
# Option 1: Keep using node_modules (no changes needed)
# Your existing setup continues to work

# Option 2: Migrate to .spin approach
# 1. Change import in spin.config.ts:
#    - import { ... } from 'spin-cli';
#    + import { ... } from './.spin/cli';
# 2. Remove spin-cli from package.json devDependencies
# 3. Run spin - it will generate .spin/cli.ts
```

### For New Projects

```bash
# Install spin globally (one time)
npm install -g spin-cli

# Initialize in any project
cd my-project
spin init

# Edit config, then run
spin up
```

---

## Why This Approach

### vs. Requiring `spin-cli` in node_modules

| Aspect | node_modules approach | .spin/cli.ts approach |
|--------|----------------------|----------------------|
| Setup time | Slow (npm install) | Instant |
| Works offline | After first install | Always |
| Team buy-in needed | Yes (package.json change) | No |
| Solo adoption | Blocked | Easy |
| Version sync | Manual npm update | Automatic on every run |
| Disk space | Full package + deps | Single generated file |
| Works in non-JS projects | Awkward | Natural |

### Key Benefits

1. **Zero friction adoption**: One developer can try spin without PRs or team discussion
2. **No dependency management**: spin manages its own types/helpers
3. **Always in sync**: `.spin/cli.ts` is regenerated each run, guaranteed to match
4. **Universal**: Same workflow for Go, Rust, Python, JS, or any project
5. **Reversible**: Just delete `.spin/` and `spin.config.ts` to fully remove

---

## Future Enhancements

1. **`.spin/local.ts`** - Local overrides not committed to git
2. **`.spin/cache/`** - Cached script metadata, last run info
3. **`.spin/history.json`** - Command history for the command palette
4. **Auto-update prompts** - "Update available, press 'u' to update"
5. **`spin eject`** - Convert `.spin/` setup to full `package.json` setup if needed
