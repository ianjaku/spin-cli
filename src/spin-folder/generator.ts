/**
 * Generates the content for .spin/cli.ts
 * This file contains all types and helper functions needed for spin.config.ts
 */

import { existsSync, readFileSync } from 'node:fs';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

/**
 * Get the current spin version from package.json
 */
export function getSpinVersion(): string {
  try {
    // When bundled, cli.js is in dist/, so package.json is one level up
    // When running from source, this file is in src/spin-folder/, so it's two levels up
    const __dirname = dirname(fileURLToPath(import.meta.url));
    
    // Try both paths
    const paths = [
      join(__dirname, '..', 'package.json'),      // From dist/
      join(__dirname, '..', '..', 'package.json'), // From src/spin-folder/
    ];
    
    for (const pkgPath of paths) {
      if (existsSync(pkgPath)) {
        const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));
        if (pkg.version) {
          return pkg.version;
        }
      }
    }
    
    return '0.0.0';
  } catch {
    return '0.0.0';
  }
}

/**
 * Generate the full content of .spin/cli.ts
 */
export function generateCliFileContent(): string {
  const version = getSpinVersion();
  
  return `// Auto-generated by spin v${version} - DO NOT EDIT
// Regenerated on each spin run to stay in sync with your spin version

// ============================================================================
// Types
// ============================================================================

export type RunnableStatus = 'stopped' | 'starting' | 'running' | 'error';

export interface RunnableDefinition {
  /** The type of runnable */
  type: 'shell' | 'docker';
  /** Human-readable name (defaults to key) */
  name?: string;
  /** Description shown in UI */
  description?: string;
  /** Command to run (for shell type) */
  command?: string;
  /** Working directory */
  cwd?: string;
  /** Environment variables */
  env?: Record<string, string>;
  /** Services this depends on (must be running first) */
  dependsOn?: string[];
  /** Function to determine if the service is ready */
  readyWhen?: (output: string) => boolean;
}

export interface SpinConfig {
  /** Runnable definitions */
  runnables: Record<string, RunnableDefinition>;
  /** Named groups of runnables */
  groups?: Record<string, string[]>;
  /** Default settings */
  defaults?: {
    /** Auto-restart on crash */
    autoRestart?: boolean;
    /** Environment variables for all runnables */
    env?: Record<string, string>;
    /** Max lines to keep in output buffer */
    maxOutputLines?: number;
  };
  /** Shell command prefixes that bypass search and run immediately */
  shellCommands?: string[];
  /** Script sources (packageScripts, scriptsFolder, etc.) */
  scripts?: ScriptSource[];
}

export type ShellOptions = Omit<RunnableDefinition, 'type' | 'command'>;
export type DockerOptions = Omit<RunnableDefinition, 'type' | 'command'> & {
  ports?: string[];
  volumes?: string[];
};

/** A resolved script ready to display in the palette and execute */
export interface ResolvedScript {
  /** Unique identifier */
  id: string;
  /** Display name shown in palette (e.g., "remix/migrate.ts") */
  displayName: string;
  /** Runner label shown on right side (e.g., "bun run", "docker (ops)") */
  runnerLabel: string;
  /** Full command to execute */
  command: string;
  /** Working directory to run in */
  cwd: string;
  /** Require confirmation before running */
  confirm?: boolean;
  /** Optional description */
  description?: string;
}

/** A script source that can resolve to multiple scripts */
export interface ScriptSource {
  /** Type of source for identification */
  type: 'packageScripts' | 'scriptsFolder';
  /** Resolve this source to concrete scripts */
  resolve(): Promise<ResolvedScript[]>;
}

/** Runner configuration for Docker execution */
export interface DockerRunnerConfig {
  type: 'docker';
  /** Container name or ID */
  container: string;
  /** Runner to use inside container (e.g., "bun run") */
  runner?: string;
}

/** Runner configuration for Kubernetes execution */
export interface KubernetesRunnerConfig {
  type: 'kubernetes';
  /** Pod selector (e.g., "app=api") */
  selector: string;
  /** Container name within the pod */
  container?: string;
  /** Namespace (defaults to "default") */
  namespace?: string;
  /** Runner to use inside container (e.g., "bun run") */
  runner?: string;
}

/** Custom runner function */
export interface CustomRunnerConfig {
  type: 'custom';
  /** Function that takes script path and returns full command */
  run: (scriptPath: string) => string;
}

/** Runner configuration - string (simple runner like "bun") or complex config */
export type RunnerConfig = string | DockerRunnerConfig | KubernetesRunnerConfig | CustomRunnerConfig;

/** Options for scriptsFolder() */
export interface ScriptsFolderOptions {
  /** Custom label for display (defaults to folder name) */
  label?: string;
  /** Override settings for specific scripts */
  overrides?: Record<string, {
    confirm?: boolean;
    description?: string;
  }>;
}

/** Options for packageScripts() */
export interface PackageScriptsOptions {
  /** Glob patterns to include (defaults to all package.json files) */
  include?: string[];
  /** Glob patterns to exclude */
  exclude?: string[];
}

// ============================================================================
// Config Helper
// ============================================================================

/**
 * Define a spin configuration with full type safety.
 */
export function defineConfig(config: SpinConfig): SpinConfig {
  return config;
}

// ============================================================================
// Runnable Helpers
// ============================================================================

/**
 * Create a shell command runnable.
 * 
 * @example
 * \`\`\`ts
 * shell('npm run dev', { cwd: './api' })
 * shell('go run ./cmd/server', { description: 'API server' })
 * \`\`\`
 */
export function shell(command: string, options: ShellOptions = {}): RunnableDefinition {
  return {
    type: 'shell',
    command,
    ...options,
  };
}

/**
 * Create a docker container runnable.
 * 
 * @example
 * \`\`\`ts
 * docker('postgres:15', { 
 *   ports: ['5432:5432'],
 *   env: { POSTGRES_PASSWORD: 'dev' }
 * })
 * \`\`\`
 */
export function docker(image: string, options: DockerOptions = {}): RunnableDefinition {
  const { ports = [], volumes = [], ...rest } = options;
  
  const args: string[] = ['docker', 'run', '--rm'];
  
  for (const port of ports) {
    args.push('-p', port);
  }
  
  for (const volume of volumes) {
    args.push('-v', volume);
  }
  
  if (rest.env) {
    for (const [key, value] of Object.entries(rest.env)) {
      args.push('-e', \`\${key}=\${value}\`);
    }
  }
  
  args.push(image);
  
  return {
    type: 'docker',
    command: args.join(' '),
    ...rest,
  };
}

// ============================================================================
// Script Helpers
// ============================================================================

/** Default shell command prefixes that bypass search */
export const defaultShellCommands = [
  'git', 'bun', 'npm', 'pnpm', 'yarn', 'node', 'docker', 'kubectl', 'make',
];

/**
 * Create a Docker runner configuration for scripts.
 */
export function dockerRunner(container: string, options?: { runner?: string }): DockerRunnerConfig {
  return {
    type: 'docker',
    container,
    runner: options?.runner,
  };
}

/**
 * Create a Kubernetes runner configuration for scripts.
 */
export function kubernetes(options: {
  selector: string;
  container?: string;
  namespace?: string;
  runner?: string;
}): KubernetesRunnerConfig {
  return {
    type: 'kubernetes',
    ...options,
  };
}

/**
 * Create a script source that discovers scripts from a folder.
 * 
 * @example
 * \`\`\`ts
 * scriptsFolder("packages/remix/scripts", "bun")
 * scriptsFolder("ops/scripts", dockerRunner("ops-container"))
 * \`\`\`
 */
export function scriptsFolder(
  path: string,
  runner: RunnerConfig,
  options?: ScriptsFolderOptions
): ScriptSource {
  return {
    type: 'scriptsFolder',
    // These are resolved by spin runtime, not here
    // @ts-expect-error - internal properties for spin runtime
    _path: path,
    _runner: runner,
    _options: options,
    async resolve() { return []; },
  };
}

/**
 * Create a script source that discovers npm/bun/pnpm scripts from package.json files.
 * 
 * @example
 * \`\`\`ts
 * packageScripts()
 * packageScripts({ exclude: ["packages/deprecated"] })
 * \`\`\`
 */
export function packageScripts(options?: PackageScriptsOptions): ScriptSource {
  return {
    type: 'packageScripts',
    // @ts-expect-error - internal properties for spin runtime
    _options: options,
    async resolve() { return []; },
  };
}
`;
}
